<?php

namespace ccxt;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception as Exception; // a common import

class bilaxy extends Exchange {

    public function describe () {
        return array_replace_recursive (parent::describe (), array (
            'id' => 'bilaxy',
            'name' => 'Bilaxy',
            'countries' => ['CN'], // Japan, Malta
            'rateLimit' => 500,
            'has' => array (
                'fetchDepositAddress' => false,
                'CORS' => false,
                'fetchBidsAsks' => true,
                'fetchTickers' => true,
                'fetchOHLCV' => false,
                'fetchMyTrades' => false,
                'fetchOrder' => true,
                'fetchOrders' => true,
                'fetchOpenOrders' => true,
                'fetchClosedOrders' => true,
                'withdraw' => false,
                'fetchFundingFees' => false,
                'fetchDeposits' => false,
                'fetchWithdrawals' => false,
                'fetchTransactions' => false,
            ),
            'urls' => array (
                'logo' => 'https://bilaxy.com/dist/images/logo.png',
                'api' => array (
                    'web' => 'https://bilaxy.com',
                    'public' => 'https://api.bilaxy.com/v1',
                    'private' => 'https://api.bilaxy.com/v1',
                    'v1' => 'https://api.bilaxy.com/v1',
                ),
                'www' => 'https://bilaxy.com',
                'doc' => 'https://bilaxy.com/api',
            ),
            'api' => array (
                'public' => array (
                    'get' => array (
                        'depth',
                        'coins',
                        'orders',
                        'ticker',
                        'tickers',
                    ),
                ),
                'private' => array (
                    'get' => array (
                        'balances',
                        'coin_address',
                        'trade_list',
                        'trade_view',
                    ),
                    'post' => array (
                        'cancel_trade',
                        'trade',
                    ),
                ),
            ),
            'fees' => array (
                'trading' => array (
                    'tierBased' => false,
                    'percentage' => true,
                    'taker' => 0.0015,
                    'maker' => 0.0015,
                ),
            ),
            'bilaxySymbols' => array (),
        ));
    }

    public function fetch_markets ($params = array ()) {
        $response = $this->publicGetCoins ();
        $markets = $response['data'];
        $result = array ();
        for ($i = 0; $i < count ($markets); $i++) {
            $market = $markets[$i];
            $id = $market['name'] . $market['group'];
            $baseId = $market['name'];
            $quoteId = $market['group'];
            $base = $this->common_currency_code($baseId);
            $quote = $this->common_currency_code($quoteId);
            $symbol = $base . '/' . $quote;
            $precision = array (
                'base' => $market['priceDecimals'],
                'quote' => $market['priceDecimals'],
                'amount' => $market['priceDecimals'],
                'price' => $market['priceDecimals'],
            );
            $active = true;
            $this->bilaxySymbols[$symbol] = $market['symbol'];
            $entry = array (
                'id' => $id,
                'symbol' => $symbol,
                'base' => $base,
                'quote' => $quote,
                'baseId' => $baseId,
                'quoteId' => $quoteId,
                'info' => $market,
                'active' => $active,
                'precision' => $precision,
                'limits' => array (
                    'amount' => array (
                        'min' => null,
                        'max' => null,
                    ),
                    'price' => array (
                        'min' => null,
                        'max' => null,
                    ),
                    'cost' => array (
                        'min' => 0.01,
                        'max' => null,
                    ),
                ),
            );
            $result[] = $entry;
        }
        return $result;
    }

    public function get_bilaxy_symbol ($symbol) {
        if ($this->bilaxySymbols === null) {
            throw new ExchangeError ($this->id . ' markets not loaded');
        }
        if ((gettype ($symbol) === 'string') && (is_array ($this->bilaxySymbols) && array_key_exists ($symbol, $this->bilaxySymbols))) {
            return $this->bilaxySymbols[$symbol];
        }
        throw new ExchangeError ($this->id . ' does not have market $symbol ' . $symbol);
    }

    public function get_symbol_from_bilaxy ($symbol) {
        if ($this->bilaxySymbols === null) {
            throw new ExchangeError ($this->id . ' markets not loaded');
        }
        $keys = is_array ($this->bilaxySymbols) ? array_keys ($this->bilaxySymbols) : array ();
        for ($i = 0; $i < count ($keys); $i++) {
            $id = $keys[$i];
            if ($this->bilaxySymbols[$id] === $symbol) {
                return $i;
            }
        }
        throw new ExchangeError ($this->id . ' does not have market symbol');
    }

    public function fetch_order_book ($symbol, $limit = null, $params = array ()) {
        $bilaxy_symbol = $this->get_bilaxy_symbol ($symbol);
        $request = array (
            'symbol' => $bilaxy_symbol,
        );
        $response = $this->publicGetDepth (array_merge ($request, $params));
        return $this->parse_order_book($response['data']);
    }

    public function parse_ticker ($symbol, $ticker, $market = null) {
        $last = $this->safe_float($ticker, 'last');
        return array (
            'symbol' => $symbol,
            'timestamp' => null,
            'datetime' => null,
            'high' => $this->safe_float($ticker, 'high'),
            'low' => $this->safe_float($ticker, 'low'),
            'bid' => $this->safe_float($ticker, 'buy'),
            'bidVolume' => $this->safe_float($ticker, 'vol'),
            'ask' => $this->safe_float($ticker, 'sell'),
            'askVolume' => $this->safe_float($ticker, 'vol'),
            'vwap' => null,
            'open' => null,
            'close' => $last,
            'last' => $last,
            'previousClose' => null,
            'change' => null,
            'percentage' => null,
            'average' => null,
            'baseVolume' => null,
            'quoteVolume' => null,
            'info' => $ticker,
        );
    }

    public function fetch_ticker ($symbol, $params = array ()) {
        $bilaxy_symbol = $this->get_bilaxy_symbol ($symbol);
        $response = $this->publicGetTicker (array_merge (array (
            'symbol' => $bilaxy_symbol,
        ), $params));
        $this->load_markets();
        $market = $this->market ($symbol);
        return $this->parse_ticker($symbol, $response['data'], $market);
    }

    public function parse_tickers ($rawTickers, $symbols = null) {
        $this->load_markets();
        $tickers = array ();
        for ($i = 0; $i < count ($rawTickers); $i++) {
            $symbol = $this->get_symbol_from_bilaxy ($rawTickers[$i]['symbol']);
            $market = $this->market ($symbol);
            $tickers[] = $this->parse_ticker($symbol, $rawTickers[$i], $market);
        }
        return $this->filter_by_array($tickers, 'symbol', $symbols);
    }

    public function fetch_tickers ($symbols = null, $params = array ()) {
        $this->load_markets();
        $rawTickers = $this->publicGetTickers ($params);
        return $this->parse_tickers ($rawTickers['data'], $symbols);
    }

    public function sign ($path, $api = 'public', $method = 'GET', $params = array (), $headers = null, $body = null) {
        $url = $this->urls['api'][$api];
        $url .= '/' . $path;
        if ($api === 'public') {
            if ($params)
                $url .= '?' . $this->urlencode ($params);
        } else {
            $this->check_required_credentials();
            $signature = $this->urlencode ($this->keysort (array_merge (array (
                'key' => $this->apiKey,
                'secret' => $this->secret,
            ), $params)));
            $signature = $this->hash ($this->encode ($signature), 'sha1');
            $query = $this->urlencode ($this->keysort (array_merge (array (
                'key' => $this->apiKey,
            ), $params)));
            $query .= '&' . 'sign=' . $signature;
            if ($method === 'GET') {
                $url .= '?' . $query;
            } else {
                $body = $query;
                $headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }
        return array ( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }
}
